### 1. 버블 정렬

정렬 : 2개 이상의 자료를 특정 기준(키)에 의해 작은 값부터 큰 값 or 반대의 순서로 재배열하는 알고리즘

- 버블 정렬 : 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
    - 시간 복잡도: O(n^2) → 이중 for 문 사용하면 대부분 시간복잡도 n^2
- 버블정렬 과정
    - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
    - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬

```python
def bubble_sort(a, N):   # 정렬할 List, 원소 수
	for i in range(N-1, 0, -1):   # 범위의 끝 위치
		for j in range(i):
			if a[j] > a[j+1]:
				a[j], a[j+1] = a[j+1], a[j]
```


### 2. 카운팅 정렬

: 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 방식

- 제한사항
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- 시간복잡도 : O(n+k)
- 정렬 과정
    1. COUNTS 배열을 만들고 각 항목들의 개수를 세서 COUNTS 배열에 해당 인덱스에 넣는다
    2. COUNTS 배열의 원소를 각 항목의 누적개수로 조정한다 → 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해
    3. 데이터의 마지막 원소의 발생횟수 `COUNTS[마지막원소]` 를 감소시키고 결과에 마지막원소를 삽입한다
    4. 3을 반복한다

```python
DATA = [1, 3, 5, 1, 2, 6, 4, 1]
TEMP = [0, 0, 0, 0, 0, 0, 0, 0]
k = 6

COUNTS = [0] * (k + 1)  # 인덱스 번호를 저장할 COUNTS 배열 선언(k는 DATA중 최댓값)

for num in DATA:  # 1단계 : DATA[i] 발생횟수를 COUNTS에 기록
    COUNTS[num] += 1

for i in range(1, k + 1):  # 2단계 : COUNTS 값 조정 (누적)
    COUNTS[i] += COUNTS[i - 1]

for i in range(len(DATA) - 1, -1, -1):  # 3단계 : 마지막 원소부터 처리
    COUNTS[DATA[i]] -= 1
    TEMP[COUNTS[DATA[i]]] = DATA[i]

print(TEMP)
```

### 3. 선택 정렬

: 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식 (오름차순의 경우)

- 정렬 과정
    1. 주어진 리스트 중에서 최소값을 찾기
    2. 그 값을 리스트의 맨 앞에 위치한 값과 교환
    3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복
- 시간 복잡도 : O(n^2)

```python
# 선택 정렬
def selection_sort(a, n): # a = 정렬할 배열, n = 배열 길이
    for i in range(n-1): # 정렬 구간의 시작 인덱스(정렬 될수록 하나씩 감소)
        min_idx = i  # 첫 원소를 최소로 가정
        for j in range(i+1, n): # min_dix 다음 값부터 비교
            if a[min_idx] > a[j]:  # 최소 인덱스를 먼저 비교하면서 찾고
                min_idx = j
        a[i], a[min_idx] = a[min_idx], a[i]  # 찾은 인덱스로 자리 교환
    return a

a = [3, 1, 8, 4, 6, 2]
print(selection_sort(a, len(a)))

>>>
[1, 2, 3, 4, 6, 8]
```