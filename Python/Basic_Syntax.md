### 프로그래밍

프로그램이란? → 문제를 해결하기 위한 **명령어들의 집합**

### Python

표현식과 값

- 표현식: 하나의 ‘값’으로 평가될 수 있는 모든 코드
    
    ex: 3+5, x > 10
    
- 값: 표현식이 평가된 결과, 더 이상 계산되거나 평가될 수 없는 프로그램의 가장 기본적인 데이터 조각

변수와 메모리

- 변수: 값을 다시 사용하기 위해, 그 값에 붙여주는 고유한 이름
- 변수 할당: 표현식이 만들어 낸 값에 이름을 붙이는 과정
- 할당문(Assignment **Statement**)
    - 값 36.5를 변수 degrees에 할당했다 : `degrees = 36.5`
        - 오른쪽 표현식 평가 → 왼쪽 변수명 확인 → 변수명과 결과값 연결
- 변수명 규칙
    - 영문 알파벳, _ , 숫자로 구성
    - 숫자로 시작할 수 없음
    - 대소문자 구분
    - 예약어 사용 불가
- 값 + 타입 + 주소 = 객체(Object)
- 변수는 특정 객체를 가리키고 **메모리 주소를 가지지 않는다**
- 변수와 할당 check
    
    ```python
    number = 10
    double = 2 * number
    print(double)  #20
    
    number = 5
    print(double)  #?
    ```
    
    print(double)의 결과는 그대로 20 출력
    

### Data Types

- 타입: 변수나 값이 가질 수 있는 데이터의 종류를 의미
- 타입의 구성요소: 값 + 연산자 (값과 값에 적용할 수 있는 연산)
- 데이터 타입 분류 5가지
    1. Numeric Types
        - int, float ~~complex(복소수)~~
    2. Text Sequence Type
        - str
    3. Sequence Types
        - list, tuple, range
    4. Non-sequence Types
        - set, dict
    5. 기타
        - Boolean, None, Functions
- 산술연산자 8종
    - +, -, *, /(사칙연산) , //(몫), %(나머지), **(거듭제곱), -(음수 부호)
- 연산자 우선순위 점검
    - `-2 ** 4`  `-(2 ** 4)`  `(-2) ** 4` 의 각 결과는?
        
        → **-16(음수부호보다 거듭제곱이 우선)**, -16, 16
        
- Sequence Type: 여러 개의 값들을 순서대로 나열하여 저장하는 자료형
- 시퀀스 타입의 5가지 공통 특징
    - 순서가 있음 but. 정렬은 아님
    - 인덱싱 가능 [ ]
    - 슬라이싱 가능 [ : : ]
    - 길이를 구할 수 있음 len( )
    - 반복할 수 있음 (하나씩 순서대로 꺼내서 사용 가능)
- 문자열(str): 순서 있는 변경 불가(immutability) 시퀀스 자료형
- 이스케이프 시퀀스 5종
    - \n: 줄 바꿈, \t: 탭, \\: 백슬래시 출력, \’: 작은따옴표 출력, \”: 큰 따옴표 출력
- ⭐**f-string 기본 문법 외 advanced 추가 학습 하기** [f-string](f_string.md)

- 인덱스가 0부터 시작하는 이유! → 인덱스는 ‘거리’의 개념, ‘시작점으로부터 얼마나 떨어져 있는가’
- 슬라이싱: 시퀀스의 일부분을 잘라내어 **새로운 시퀀스**를 만들어 냄

### 추가

- 코드에서 진법 표현하기

| 진법 | 접두사 | 사용하는 숫자/문자 |
| --- | --- | --- |
| 2진수 (binary) | 0b | 0과 1 |
| 8진수 (octal) | 0o | 0부터 7까지 |
| 16진수 (hexadecimal) | 0x | 0부터 9, a부터 f |
- 실수 계산 시 부동소수점으로 인한 계산 오류 해결법
    - decimal 모듈을 사용해서 해결
    
    ```python
    from decimal import Decimal
    
    a = Decimal('3.2') - Decimal('3.1')  # 0.1
    a = Decimal('1.2') - Decimal('1.1')  # 0.1
    
    print(a)  # 0.1
    print(b)  # 0.1
    print(a == b)   # True
    ```
    
- 표현식 vs 문장
    - 표현식: 하나의 값으로 평가될 수 있는 모든 코드
    - 문장: 특정 동작을 지시하는, 실행 가능한 코드의 최소 단위
    - 헷갈리면 “이 코드를 실행하면, 하나의 값이 남는지” 생각해보기
- Style Guide
    - 변수명 직관적인 이름
    - 공백은 4칸
    - 한 줄의 길이는 79자로 제한, 길어지면 줄바꿈
    - 문자와 밑줄(_)로 함수, 변수, 속성의 이름을 작성
    - 함수 정의나 클래스 정의 시 빈 줄을 추가
- 공부 할 때 참고하기 좋은 사이트
    - [https://pythontutor.com/](https://pythontutor.com/visualize.html#mode=edit) - python 코드 돌아가는거 시각적으로 보여주는 사이트

### 핵심 키워드

| 개념 | 설명 | 예시 |
| --- | --- | --- |
| 표현식 (Expression) | 값을 만들어내는 코드 조각 | 3+5, “Hello”, 2*a  |
| 값 (Value) | 표현식이 만들어내는 결과물 | 8, “hello”, True |
| 문장 (Statement) | 실행 가능한 코드 한 줄 | print(”hello”), a=3 |
| 변수 (Variable) | 값을 저장하는 이름표 (메모리 주소 참조) | a=10 |
| 할당 (Assignment) | 값을 변수에 저장하는 행위 | temp = 36.5 |
| 데이터 타입 (Data Type) | 값의 종류 (숫자, 글자 등) | int, float, str … |
| 산술 연산자 | 수학적 계산에 사용되는 기호들 | +, -, * , / , //, %, ** |



## List

: 여러 개의 값을 **순서대로** 저장하는, **변경 가능한** (mutable) 시퀀스 자료형

- 대괄호 [ ] 안에 값들을 쉼표로 구분하여 만듦
- 중첩 리스트(Nested List) : 다른 리스트를 값으로 가진 리스트
    
    ```python
    my_list = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
    
    print(my_list[4][-1])     # !!!
    print(my_list[-1][1][0])  # w
    ```
    
    - 이 딴 식으로 계속 중첩해서 인덱스로 안에 값 접근할 수 있음
    
    ```python
    my_list = [1, 2, 3, 4, 5]
    my_list[2:4] = ['three', 'four', 'ssafy']
    
    >> [1, 2, 'three', 'four', 'ssafy', 5]
    ```
    
    - 꼭 같은 갯수를 넣어야 하는거 아님 ㅇㅇ “왼쪽 영역에 오른쪽 값을 추가한다”는 개념
    
    ### 이렇게 쓰면?
    
    ```python
    # 이상한 짓 1
    # 이렇게 하면 어떻게 되지?
    
    my_list = [1, 2, 3, 4, 5]
    my_list[2:4] = ['three', 'four']['?!']
    
    >> TypeError: list indices must be integers or slices, not str
    
    #오른쪽 표현식을 평가할 때 인덱싱 불가해서 바로 에러 발생
    ```
    
    <aside>
    💡
    
    에러는 할당 연산자(`=`)의 오른쪽에서 발생합니다. 그 이유는 **리스트를 인덱싱(indexing)할 때 문자열을 사용했기 때문**입니다.
    
    1. **표현식 평가:** 파이썬은 먼저 `['three', 'four']['?!']`의 값을 계산하려고 합니다.
    2. **잘못된 인덱스:** 리스트의 특정 항목을 가리키는 인덱스로는 **정수**(예: `0`, `1`)나 **슬라이스**(예: `0:2`)만 사용할 수 있습니다.
    3. **TypeError 발생:** `'?!'`는 문자열이므로, 파이썬은 "list indices must be integers or slices, not str" (리스트 인덱스는 정수나 슬라이스여야 합니다, 문자열은 안됩니다) 라는 메시지와 함께 `TypeError`를 일으킵니다.
    
    이 에러로 프로그램이 즉시 중단되기 때문에, `my_list`에 값을 할당하는 코드는 실행되지 않습니다. 따라서 `my_list`는 `[1, 2, 3, 4, 5]` 그대로 남아있게 됩니다.
    
    </aside>
    
    ```python
    # 이상한 짓 2
    # 그럼 인덱싱 숫자를 쓰면??
    my_list = [1, 2, 3, 4, 5]
    my_list[2:4] = ['three', 'four'][0]
    
    >> [1, 2, 't', 'h', 'r', 'e', 'e', 5]
    #['three', 'four'][0] 부터 해서 'three' 나오고 2:4 범위에 문자열 순서대로 각각 추가함
    ```
    
    ```python
    #이상한 짓 3
    #그럼 'three'를 통째로 요소로 넣고 싶으면??
    my_list = [1, 2, 3, 4, 5]
    my_list[2:4] = [['three'], 'four'][0]
    
    >> [1, 2, 'three', 5]
    ```
    
    <aside>
    💡
    
    사용자님의 원래 코드 `my_list[2:4] = ['three', 'four'][0]`는 `my_list[2:4] = 'three'`와 같습니다.
    
    리스트의 슬라이스(`my_list[2:4]`)에 **문자열을 바로 할당하면**, 파이썬은 그 문자열을 각각의 문자 `'t'`, `'h'`, `'r'`, `'e'`, `'e'`로 이루어진 iterable(반복 가능한 객체)로 취급하여 리스트에 삽입합니다. 그래서 결과가 `[1, 2, 't', 'h', 'r', 'e', 'e', 5]`가 됩니다.
    
    `'three'`라는 문자열을 **하나의 완전한 요소**로 넣으려면, 리스트로 한 번 더 감싸서 `['three']` 형태로 만들어주어야 합니다. 이렇게 하면 파이썬은 슬라이스 부분을 `['three']` 리스트 안의 요소(즉, `'three'` 문자열 하나)로 정확히 교체합니다.
    
    </aside>
    

## Tuple

: 여러 개의 값을 **순서대로** 저장하는 **변경 불가능한** 시퀀스 자료형

- 소괄호 ( ) 안에 값들을 쉼표로 구분하여 만듦 → 하지만 소괄호가 없어도 됨
- 요소가 1개면 반드시 후행 쉼표(Trailing comma)를 써야 함  → 왜일까요??
- 튜플은 다중 할당, 값 교환, 함수 다중 반환 값 등에 사용됨
    - 불편 특성을 사용해 내부 동작과 관련하여 안전한 데이터 전달에 사용
        
        → **내부적으로 여러 값을 사용하는 경우 묶는 자료형: 튜플**
        

```python
# 값 교환
x, y = 1, 2
x, y = y, x

# 실제 내부 동작
temp = (y, x)  # 튜플 생성
x, y = temp    # 언패킹(튜플 풀어냄)
print(x, y)    # 2 1
```

## Range

: 연속된 정수 시퀀스를 **생성**하는 **변경 불가능한** 자료형

→ range **객체**를 반환 → 그냥 print 하면 range 출력함 → 리스트 확인하려면 형변환 해야 함 ㅇㅇ

<aside>
💡

실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 ‘규칙’만 기억하여 메모리를 효율적으로 사용!!

</aside>

- `range( start, stop, step )`
- step 값은 간격과 **방향**을 결정
- 주로 반복문이랑 씀~

## Dict

: **key - value 쌍**으로 이루어진 **순서와 중복이 없는,** **변경 가능한** 자료형

- 중괄호 { } 안에 값들이 쉼표로 구분되어 있음
- 값은 `key : value` 식으로 구성
- 최근 버전에서는 입력한 순서 그대로 출력해 주지만 그게 순서가 있다는 뜻은 아님
- key는 고유해야 하고 변경 불가능 해야 함 → str, int, float, tuple 사용 가능
- value는 자유롭게 사용할 수 있음

<aside>
💡

존재하지 않는 key로 접근하면 **KeyError** 발생

</aside>

- 데이터에 순서가 필요 없고, 각 데이터에 이름을 붙여 관리할 때 사용 + api 자료 받을 때 “JSON”
    
    ex. 회원 정보, 게임 캐릭터 능력치 등
    

## Set

: **순서와 중복이 없는,** **변경 가능한** 자료형

- 중괄호 { } 안에 값들을 쉼표로 구분하여 만듦
- 비어 있는 set는 함수 호출해서 만들어야 함 `set( )`
- 합집합( | ) , 교집합( & ), 차집합( - ) 계산

## Other Types

1. None : ‘값이 없음’ 을 표현하는 데이터 타입
    - 숫자 0 이나 빈문자열 ‘’이랑 다름!
    - None 에서 N은 꼭 대문자로 써야 함!
2. Boolean : 참 or 거짓
    - 비교 논리 연산에 사용
    - True, False 에서 T, F 대문자~~

## Collection

: 여러 개의 값을 하나로 묶어 관리하는 자료형을 통칭하는 말

- str, list, tuple, range, set, dict

    | 컬렉션명 | 변경 가능 여부 | 순서 존재 여부|
    | --- | --- | --- |
    | str | x | o |
    | list | o | o |
    | tuple | x | o |
    | dict | o | x |
    | set | o | x |

- 불변 vs 가변  → 설계 관점에서 추가 학습?!, 얕은 복사와 깊은 복사?!?! 2개?!?!
    
    [얕은 복사와 깊은 복사](Shallow_copy_deep_copy.md)
    
    - 불변은 그 자체를 참조하는 주소를 저장 → 요소 변경 불가
    - 가변은 안에 요소 별로 참조하는 주소를 저장 → 요소를 변경 가능
    
    | 구분 | 불변(immutable) | 가변(mutable) |
    | --- | --- | --- |
    | 특징 | 변경 불가, 안전, 예측 가능 | 변경 가능, 유연성, 효율성 |
    | 종류 | str, tuple, **range** | list, dict, **set** |

## 형변환

: 한 데이터 타입을 다른 데이터 타입으로 변환하는 과정

- 암시적 형변환 : 파이썬이 해줌, 더 정밀한 타입으로 해줌(고맙,,)

```python
# 정수 + 실수
print(3+ 5.0)   # 8.0

# 불리언 + 정수
print(True + 3)  # 4

# 불리언 간
print(True + False) # 1
```

- 명시적 형변환 : 개발자가 직접 함
- 되는 것도 있고 안되는 것도 있는데 상식적으로 생각 해보자

## 연산자

- 산술연산자
- 복합연산자
- 비교연산자
    - == 와 is, != 와 is not
    - ==는 값 비교(동등성), is 는 객체 자체를 비교(식별성) - 완전히 동일한 메모리 주소를 가지는지
    
    ```python
    # == 연산자 (동등성)
    print(2 == 2.0)      # True
    print(2 != 2)        # False
    print('HI' == 'hi')  # False
    print(1 == True)     # True
    
    # is 연산자 (식별성)
    print(1 is True)     #False
    print(2 is 2.0)      #False
    
    # 리스트 비교 예시
    a = [1, 2, 3]
    b = [1, 2, 3]
    
    print(a == b) # True
    print(a is b) # False
    
    b = a         # b가 a를 그대로 참조하면
    print(a is b) # True
    ```
    
    <aside>
    💡
    
    is 는 웬만하면 잘 안 씀
    
    주로 값 비교할 경우가 많으므로 ==를 더 자주 씀
    
    그럼 is 언제 쓰냐? → 주로 싱글턴 객체를 비교할 때 씀 (ex. None, True, False)
    
    `if x is None:` 이딴식으로 씀
    
    </aside>
    
- 논리연산자
    - 단축평가 : 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작
    
    ```python
    # or 평가 시, 앞에 결과가 이미 True 여서 뒤에는 안 함
    name = 'Alice'
    age = 25
    result = (name == 'Alice') or (age == 30)
    print(result)  #True
    ```
    
    ### 단축 평가 and 연산자 예시 문제
    
    ```python
    item1 = '지도'
    item2 = '나침반'
    result = item1 and item2
    print(f'최종적으로 챙긴 물건: {result}')
    
    >> 최종적으로 챙긴 물건: 나침반
    
    item1 = ''
    item2 = '나침반'
    result = item1 and item2
    print(f'최종적으로 챙긴 물건: {result}')
    
    >> 최종적으로 챙긴 물건: ''
    # item2 는 확인 안 함 
    ```
    
- 멤버십 연산자 : 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
    - in : 시퀀스에 속하는지 확인
    - not in : 시퀀스에 속하지 않는지 확인
- 시퀀스형 연산자 : 시퀀스 자료형에 특별한 의미로 사용되는 연산자
    - + : 결합
    - * : 반복
- 연산자 우선순위
    - ( )로 좀 묶어라;;
    - **인덱싱, 슬라이싱 > 거듭제곱 > 양수/음수 > 곱하기, 나누기 > 더하기, 빼기**

## 추가

- Trailing Comma (후행 쉼표) : 컬렉션의 마지막 요소 뒤에 붙는 쉼표로 선택사항인데 요소 하나 밖에 없는 튜플에는 필수임 ㅇㅇ
- 후행 쉼표 쓸거면 보기 편하게 줄바꿈 해주는게 좋음 (권장)

<aside>
💡

다음 코드의 결과로 올바른 것을 고르시오.

x = 0

print(x or 5)

</aside>

결과: `True`  아니고 `5` 가 결과임 → or 연산자의 결과로 True 인 5가 출력됨 

## 핵심 키워드

| 개념 | 설명 |
| --- | --- |
| 리스트 | 순서가 있고, 수정 가능한 값들의 묶음 |
| 딕셔너리 | 순서 없이 key-value 쌍으로 이루어진 데이터 묶음 |
| 형 변환 | 데이터의 타입을 의도적으로 변경하는 것 |
| Boolean | 참 또는 거짓을 나타내는 데이터 타입 |
| 멤버십 연산자 | 특정 값이 컬렉션에 포함되어 있는지 확인하는 연산자 |
| 논리 연산자 | 여러 조건을 조합하거나 반전시키는 연산자 |
| 단축 평가 | 논리 연산에서 전체 결과가 확정되면 나머지 부분은 평가하지 않는 동작 |